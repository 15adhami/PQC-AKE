
# This file was *autogenerated* from the file kem_light.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2p99 = RealNumber('2.99'); _sage_const_4 = Integer(4); _sage_const_12889 = Integer(12889)# Lightweight KEM Example #

from IPython import embed
#import numpy as np
#import sys

q = _sage_const_12889 
n = _sage_const_4  # < n^n+1 > ; n = 2^i

R = ZZ['x']; (x,) = R._first_ngens(1);
#R = PolynomialRing(ZZ,"x")
Rz = R.quotient(x**n+_sage_const_1 )

Rq = PolynomialRing(GF(q),"x")
Rq = Rq.quotient(x**n+_sage_const_1 )

R2 = PolynomialRing(GF(_sage_const_2 ),"x")
R2 = R2.quotient(x**n+_sage_const_1 )


################################################################
# Helper Functions
################################################################

# Maps coefficients to [-(p-1/2),(p-1)/2]
# In the case pp=2 notice that it will just perform regular modulo 2
def modCoeffs(f,pp):
    clist=f.list()
    p2=int(pp/_sage_const_2 )
    for i in range(len(clist)):
        clist[i] = int(clist[i])%pp
        #print clist[i],p2,clist[i]>p2,int(clist[i])-pp,type(clist[i]),clist[i]*-1
        if clist[i]>p2:
            clist[i]= int(clist[i]) - pp
            #print clist[i]


    return R(clist)

# Generate a polynomial
def __genPolynomial(n,q,check_inverse=False):

    poly = [_sage_const_0 ]
    while (poly[len(poly)-_sage_const_1 ] == _sage_const_0 ): #Force polynomial to be filled
        poly = np.asarray(np.random.normal(_sage_const_0 ,_sage_const_2p99 ,size=n),dtype=int)
        
        if (check_inverse):
            try:
                Rq(list(poly))**-_sage_const_1 
                R2(list(poly))**-_sage_const_1 
            except:
                poly = [_sage_const_0 ] #Force while loop to continue;
    #return self.__modCoeffs(np.asarray(self.R(list(poly)).list(),dtype=int))
    return list(poly)

################################################################
# Actual KEM
################################################################

print "\nNote: [5,6,7,8] refers to 8x^3 + 7x^2 + 6x + 5"
######################## Key Generation ########################
print "\nKeyGen"

#Randomly choosing f and g (wiht small norms)
f = [-_sage_const_3 ,-_sage_const_1 , _sage_const_0 , _sage_const_1 ] # 1x^3 + 0x^2 - 1x - 3    ## __genPolynomial(n,q,check_inverse=True)
g = [ _sage_const_1 ,-_sage_const_2 , _sage_const_1 , _sage_const_1 ] # 1x^3 + 1x^2 - 2x + 1    ## __genPolynomial(n,q,check_inverse=True)

print "f:",f
print "g:",g

# Checking both f,g are invertible in Zp/<x^n+1> and Z2/<x^n+1>
# Otherwise the following two lines would crash
Rq(f)**-_sage_const_1  ; R2(f)**-_sage_const_1 
Rq(g)**-_sage_const_1  ; R2(g)**-_sage_const_1 
print "g & f are invertible"



# G inverse
#g_inv = (inv_poly_mod_prime_pow__(R(g))[1]).list()
#print Rq(Rz(g)*Rz(g_inv))
g_inv = (Rq(g)**-_sage_const_1 )
g_inv = modCoeffs(g_inv,q)
print "g^-1:", g_inv.list()

print "(g*g^-1):",Rq(Rz(g)*Rz(g_inv))

#print "Inverse_Sam:",inv_poly_mod_prime_pow__(R(g))[1] # Doesn't seem to work
#print "Inverse_Rq:",Rq(g)**-1 #What im using right now
#print "Inverse_R2:",R2(g)**-1 #Doesn't seem to work + breaks the encapsulation

h = R(f)*(R(g_inv))
h = modCoeffs(Rz(h),q)
#h = Rq(h)
h = h.list()  # (Doing this to move things around as lists)
print "h:",h


######################## Encapsulation #########################
print "\nEncapsulation"

#Randomly Generating r and e (with small norms)
r = [ _sage_const_1 ,-_sage_const_2 , _sage_const_0 , _sage_const_1 ] ## __genPolynomial(n,q,check_inverse=False)
e = [ _sage_const_2 ,-_sage_const_1 ,-_sage_const_1 , _sage_const_1 ] ##__genPolynomial(n,q,check_inverse=False)
print "r:",r
print "e:",e

# Notice, unlike f & g, we don't care if r & e are invertible.

# t = 2hr + e (mod q)
t = _sage_const_2 *R(h)*R(r) + R(e)  # t = 2hr + e
t = Rz(t)               # t modulo the polynomial <x^n+1>
t = modCoeffs(t,q)      # coeffs of t modulo q
#t = Rq(t)
t = t.list()           
print "t (c):",t

k = R2(e).list()        # k = e % 2
print "k:",k

######################## Decapsulation ##########################
print "\nDecapsulation"

# k = ( (gt mod q mod 2)/ g )(mod 2)
k2 = R(g)*R(t)          # k = gt
k2 = Rz(k2)             # gt modulo the polynomial <x^n+1>
k2 = modCoeffs(k2,q)    # k = (gt) mod p
#k2 = Rq(k2).list()
k2 = R2(k2).list()      # k = (gt mod p) mod 2

#print "Nominator (gt mod q mod 2): ",k2 

k2 = R(k2)*R(g_inv)     # (gt mod p mod 2 )/g
k2 = Rz(k2)             # (gt mod p mod 2 )/g modulo the polynomial <x^n+1>
k2 = R2(k2)             # ((gt mod p mod 2 )/g) mod 2
k2 = k2.list()

### RESULTS ###
print "[Goal: k == k' ; t != k]"
print "k: ",k
print "k':",k2
if (k==k2): print "Valid!"
else: print "Invalid!"
print "t: ",t,"\t%2= ",modCoeffs(R(t),_sage_const_2 ).list()
embed()

##################################################################
##################################################################
##################################################################
# THIS CODE BELOW IS NOT IN USE
##################################################################
# Code Borrowed from Sam Green's NTRU Implementation
##################################################################

def posResidue(poly, base):
    clist = poly.list()
    for i in range(len(clist)):
        clist[i] = clist[i]%base
        if clist[i] < _sage_const_0 :
            clist[i] += base
    return R(clist)

def inv_poly_mod2__(poly):
    k=_sage_const_0 ;b=_sage_const_1 ;c=_sage_const_0 *x;
    f=poly;g=x**n-_sage_const_1 
    f=modCoeffs(f, _sage_const_2 )
    res=False
    while True:
        while f(_sage_const_0 )==_sage_const_0  and not f.is_zero():
            f=f.shift(-_sage_const_1 )
            c=c.shift(_sage_const_1 )
            #c=self.modCoeffs(c, 2)
            c = posResidue(c,_sage_const_2 )
            k+=_sage_const_1 
        if f.is_one():
            e=(-k)%n
            retval= x**e*b 
            res=True
            break
        elif f.degree()==-_sage_const_1  or f.is_zero():
            break
        if f.degree()<g.degree():
            f,g=g,f
            b,c=c,b
        f=f+g
        b=b+c
        #f=self.modCoeffs(f, 2)
        f=posResidue(f,_sage_const_2 )
        #c=self.modCoeffs(c, 2)
        c=posResidue(c,_sage_const_2 )
    if res:
        retval=retval%(x**n-_sage_const_1 )
        #retval=self.modCoeffs(retval, 2)
        retval = posResidue(retval, _sage_const_2 )
        return True, retval
    else:
        return False,_sage_const_0 

def inv_poly_mod_prime_pow__(poly):
    res,b=inv_poly_mod2__(poly)
            #print "Inside __inv_poly_mod_prime_pow__(): res={}, b={}".format(res,b)
    if res:
        qr=_sage_const_2 
        while qr<q:
            qr=qr**_sage_const_2 
            b=b*(_sage_const_2 -poly*b)
            b=b%(x**n-_sage_const_1 )
            #b=self.modCoeffs(b, self.q)
            b = posResidue(b, q)
        return True,b
    else:
        return False,_sage_const_0 


################ RANDOM RAMBLINGS ################
#a = modCoeffs(Rq(r)*modCoeffs(Rq(f)/Rq(g),q) + Rq(e),q)
#a = modCoeffs(modCoeffs(a*Rq(g),q),2)
#a = modCoeffs(a/Rq(g),2)
#a = modCoeffs( ( (Rq(r)*Rq(f)/Rq(g) + Rq(e) )*Rq(g) ), 2)
#a = Rq(f)/Rq(g)*Rq(r)+Rq(e)

