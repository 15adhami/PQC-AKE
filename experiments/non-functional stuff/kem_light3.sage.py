
# This file was *autogenerated* from the file kem_light3.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2p99 = RealNumber('2.99'); _sage_const_4 = Integer(4); _sage_const_12889 = Integer(12889)# Lightweight KEM Example #

from IPython import embed
import numpy as np
#import sys

q = _sage_const_12889 
n = _sage_const_4  # < n^n+1 > ; n = 2^i

R = ZZ['x']; (x,) = R._first_ngens(1);
#R = PolynomialRing(ZZ,"x")
Rz = R.quotient(x**n+_sage_const_1 )

Rq = PolynomialRing(GF(q),"x")
Rq = Rq.quotient(x**n+_sage_const_1 )

R2 = PolynomialRing(GF(_sage_const_2 ),"x")
R2 = R2.quotient(x**n+_sage_const_1 )



################################################################
# Helper Functions
################################################################

# Generate a polynomial
def __genPolynomial(n,q,check_inverse=False):

    poly = [_sage_const_0 ]
    while (poly[len(poly)-_sage_const_1 ] == _sage_const_0 ): #Force polynomial to be filled
        poly = np.asarray(np.random.normal(_sage_const_0 ,_sage_const_2p99 ,size=n),dtype=int)
        
        if (check_inverse):
            try:
                Rq(list(poly))**-_sage_const_1 
                R2(list(poly))**-_sage_const_1 
            except:
                poly = [_sage_const_0 ] #Force while loop to continue;
    #return self.__modCoeffs(np.asarray(self.R(list(poly)).list(),dtype=int))
    return list(poly)



################################################################
# Actual KEM
################################################################

print "\nNote: [5,6,7,8] refers to 8x^3 + 7x^2 + 6x + 5"
######################## Key Generation ########################
print "\nKeyGen"

#Randomly choosing f and g (wiht small norms)
f = [-_sage_const_3 ,-_sage_const_1 , _sage_const_0 , _sage_const_1 ] # 1x^3 + 0x^2 - 1x - 3    ## __genPolynomial(n,q,check_inverse=True)
g = [ _sage_const_1 ,-_sage_const_2 , _sage_const_3 , _sage_const_1 ] # 1x^3 + 1x^2 - 2x + 1    ## __genPolynomial(n,q,check_inverse=True)

print "f:",f
print "g:",g

# Checking both f,g are invertible in Zp/<x^n+1> and Z2/<x^n+1>
# Otherwise the following two lines would crash
Rq(f)**-_sage_const_1  ; R2(f)**-_sage_const_1 
Rq(g)**-_sage_const_1  ; R2(g)**-_sage_const_1 
print "g & f are invertible"

g_inv = Rq(g)**-_sage_const_1 

h = R(f)*g_inv


######################## Encapsulation #########################
print "\nEncapsulation"

#Randomly Generating r and e (with small norms)
r = [ _sage_const_1 ,-_sage_const_2 , _sage_const_0 , _sage_const_1 ] ## __genPolynomial(n,q,check_inverse=False)
e = [ _sage_const_2 ,-_sage_const_1 , -_sage_const_1 , _sage_const_1 ] ##__genPolynomial(n,q,check_inverse=False)
print "r:",r
print "e:",e

t = _sage_const_2 *h*R(r)+R(e)
k = R2(e)

######################## Decapsulation ##########################

k2 = R(g)*t
k2 = R2(k2.list())
k2 = R(k2.list())*g_inv
k2 = R2(k2.list())


print "\nResults:----------\n"
print "k: ", k.list()
print "k2: ", k2.list()
print "t: ", t.list()
print "t%2: ",R2(t.list()).list()


################
print "\n\nTest"
print "2fr+ef in Z  :",(_sage_const_2 *(R(f)*R(r))%(x**_sage_const_4 +_sage_const_1 )+(R(e)*R(g))%(x**_sage_const_4 +_sage_const_1 ))
print "2fr+eg in Zq :",Rq(_sage_const_2 *R(f)*R(r)+R(e)*R(g))
print "gt mod q     :",Rq(R(g)*R(t.list()))
print "\n\n"

################


embed()

