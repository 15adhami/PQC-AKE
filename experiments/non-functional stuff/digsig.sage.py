
# This file was *autogenerated* from the file digsig.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2p99 = RealNumber('2.99'); _sage_const_4 = Integer(4); _sage_const_1p77 = RealNumber('1.77'); _sage_const_12889 = Integer(12889); _sage_const_16 = Integer(16)####      Digital Signature        ###
### Hash-and-Sign Message Recovery ###

from IPython import embed
import numpy as np
import hashlib
from sage.stats.distributions.discrete_gaussian_lattice import DiscreteGaussianDistributionLatticeSampler as GaussDistSampler

q = _sage_const_12889 
n = _sage_const_4  # < n^n+1 > ; n = 2^i

R = ZZ['x']; (x,) = R._first_ngens(1);
#R = PolynomialRing(ZZ,"x")
Rz = R.quotient(x**n+_sage_const_1 )

_Rq = PolynomialRing(GF(q),"x")
Rq = _Rq.quotient(x**n+_sage_const_1 )

R2 = PolynomialRing(GF(_sage_const_2 ),"x")
R2 = R2.quotient(x**n+_sage_const_1 )




################################################################
# Helper Functions
################################################################

# Generate a polynomial
def __genPolynomial(n,q,check_inverse=False):

    poly = [_sage_const_0 ]
    while (poly[len(poly)-_sage_const_1 ] == _sage_const_0 ): #Force polynomial to be filled
        poly = np.asarray(np.random.normal(_sage_const_0 ,_sage_const_2p99 ,size=n),dtype=int)
        
        if (check_inverse):
            try:
                Rq(list(poly))**-_sage_const_1 
                R2(list(poly))**-_sage_const_1 
            except:
                poly = [_sage_const_0 ] #Force while loop to continue;
    #return self.__modCoeffs(np.asarray(self.R(list(poly)).list(),dtype=int))
    return list(poly)

################################################################
# Actual KEM
################################################################

######################## Signature Key Generation ##############

f = __genPolynomial(n,q,check_inverse=False);
g = __genPolynomial(n,q,check_inverse=True);


h = Rq(f)*(Rq(g)**-_sage_const_1 )
h = h.list()

Ks = (f,g)
Kv = h


######################## Sign ###################################

m = [_sage_const_1 ,_sage_const_2 ,_sage_const_3 ,_sage_const_4 ]

sigma = float(_sage_const_1p77 *sqrt(q))

t = int(hashlib.sha256(str(m)).hexdigest(),_sage_const_16 )

t = [_sage_const_1 ,_sage_const_2 ,_sage_const_3 ,_sage_const_4 ]

s1 = vector(ZZ,t) - GaussDistSampler(ZZ**n,sigma,t)()
s2 = vector(ZZ,[_sage_const_0 ]*n) - GaussDistSampler(ZZ**n,sigma)()

embed()




