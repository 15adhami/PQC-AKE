
# This file was *autogenerated* from the file kem_light2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2p99 = RealNumber('2.99'); _sage_const_12889 = Integer(12889); _sage_const_512 = Integer(512)# Lightweight KEM Example #

from IPython import embed
import numpy as np
#import sys

q = _sage_const_12889 
n = _sage_const_512  # < n^n+1 > ; n = 2^i

R = ZZ['x']; (x,) = R._first_ngens(1);
#R = PolynomialRing(ZZ,"x")
Rz = R.quotient(x**n+_sage_const_1 )

Rq = PolynomialRing(GF(q),"x")
Rq = Rq.quotient(x**n+_sage_const_1 )

R2 = PolynomialRing(GF(_sage_const_2 ),"x")
R2 = R2.quotient(x**n+_sage_const_1 )



################################################################
# Helper Functions
################################################################

# Generate a polynomial
def __genPolynomial(n,q,check_inverse=False):

    poly = [_sage_const_0 ]
    while (poly[len(poly)-_sage_const_1 ] == _sage_const_0 ): #Force polynomial to be filled
        poly = np.asarray(np.random.normal(_sage_const_0 ,_sage_const_2p99 ,size=n),dtype=int)
        
        if (check_inverse):
            try:
                Rq(list(poly))**-_sage_const_1 
                R2(list(poly))**-_sage_const_1 
            except:
                poly = [_sage_const_0 ] #Force while loop to continue;
    #return self.__modCoeffs(np.asarray(self.R(list(poly)).list(),dtype=int))
    return list(poly)


# Reduction a modulo q that maps coeffs: [-(q-1)/2 , -(q-1)/2]
def modCoeffs(f,pp):
    clist=f.list()
    p2=int(pp/_sage_const_2 )
    for i in range(len(clist)):
        clist[i] = int(clist[i])%pp
        #print clist[i],p2,clist[i]>p2,int(clist[i])-pp,type(clist[i]),clist[i]*-1
        if clist[i]>p2:
            clist[i]= int(clist[i]) - pp
            #print clist[i]


    return R(clist)



################################################################
# Actual KEM
################################################################
def kem(n,q):

    print "\nNote: [5,6,7,8] refers to 8x^3 + 7x^2 + 6x + 5"
    ######################## Key Generation ########################
    print "\nKeyGen"

    #Randomly choosing f and g (wiht small norms)
    f = __genPolynomial(n,q,check_inverse=True) # [-3,-1, 0, 1] # 1x^3 + 0x^2 - 1x - 3    ## __genPolynomial(n,q,check_inverse=True)
    g = __genPolynomial(n,q,check_inverse=True) # [ 1,-2, 1, 3] # 1x^3 + 1x^2 - 2x + 1    ## __genPolynomial(n,q,check_inverse=True)

    print "f:",f
    print "g:",g

    # Checking both f,g are invertible in Zp/<x^n+1> and Z2/<x^n+1>
    # Otherwise the following two lines would crash
    Rq(f)**-_sage_const_1  ; R2(f)**-_sage_const_1 
    Rq(g)**-_sage_const_1  ; R2(g)**-_sage_const_1 
    print "g & f are invertible"

    g_inv = Rq(g)**-_sage_const_1 
    g_inv = modCoeffs(g_inv,q).list()

    h = R(f)*R(g_inv)
    h = h%(x**n+_sage_const_1 )
    h = modCoeffs(h,q)
    print "h: ",h
    h = h.list()


    ######################## Encapsulation #########################
    print "\nEncapsulation"

    #Randomly Generating r and e (with small norms)
    r = __genPolynomial(n,q,check_inverse=False) # [ 1,-2, 0, 1] ## __genPolynomial(n,q,check_inverse=False)
    e = __genPolynomial(n,q,check_inverse=False) #[ 2,-1,-1, 1] ##__genPolynomial(n,q,check_inverse=False)
    print "r:",r
    print "e:",e

    t = R(h)*R(r)
    t = t%(x**n+_sage_const_1 )
    t = modCoeffs(t,q)
    t = _sage_const_2 *t
    t = modCoeffs(t,q)

    print "t1:,",t

    t = t+R(e)
    t = modCoeffs(t,q)

    print "t:,",t

    t = t.list()

    k = R2(e).list()


    ######################## Decapsulation ##########################

    k2 = R(g)*R(t)
    k2 = k2%(x**n+_sage_const_1 )
    k2 = modCoeffs(k2,q)

    print "k''':",k2

    k2 = modCoeffs(k2,_sage_const_2 )
    print "k'':",k2

    k2 = k2*R((R2(g)**-_sage_const_1 ).list())
    k2 = k2%(x**n+_sage_const_1 )

    print "k':",k2
    k2 = modCoeffs(k2,_sage_const_2 )

    k2 = k2.list()


    print "\nResults:----------\n"
    print "k: ", k
    print "k2: ", k2
    print "t: ", t
    print "t%2: ",R2(t).list()



    ####
    print "\n\n\n\n Testing"
    print "2fr+ge",Rq(_sage_const_2 *R(f)*R(r)+R(g)*R(e))
    print "gt mod q",Rq(R(g)*R(t))

    print "Valid:",k == (k2 + [_sage_const_0 ]*(len(k)-len(k2)))
    k2
    print len(k),len(k2)





kem(n,q)

